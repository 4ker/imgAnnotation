#!/usr/bin/perl

# string with usage information
my $usage = <<"EOD";

usage: convert_results.pl <imageList> <imageWidths> [[--flipped] <objType> <view> <resultsTxt>]...

  <imageList>  The list file that has been used for the detection results.

  <imageWidths> A list file that contains the corresponding with for each image
                in <imageList>.

  <objType>  The object type of the detector (face, head, etc.)

  <view>  The view of the object (frontal, side)

  <resultsTxt>  The path to a results.txt file generated by Navneet's detector

  --flipped  Optional parameter indicating that the image has been flipped
             horizontally.

  Note: The last three options can be repeaded as often as you like, different
        body part types/views will thus be merged directly.

EOD

# check command line arguments 
if (@ARGV < 5 || "--help" eq $ARGV[0]) {
	print "$usage";
	exit(0);
}

# get the command line arguments
my $IMAGELISTFILE = shift(@ARGV);
my $IMAGEWIDTHFILE = shift(@ARGV);
my $c = 0;
my @TYPES;
my @VIEWS;
my @FLIPPED;
my @RESULTFILES;
my $flipped = 0;
foreach $i (@ARGV) {
	if ($i =~ /--flipped/i) {
		$flipped = 1;
		next;
	}
	if ($c == 0) {
		push(@TYPES, $i);
	}
	elsif ($c == 1) {
		push(@VIEWS, $i);
	}
	else {
		push(@RESULTFILES, $i);
		push(@FLIPPED, $flipped);
		$flipped = 0;
	}
	$c = ($c + 1) % 3;
}
die "error .. length of arrays not equal!\n" if (@TYPES != @VIEWS || @VIEWS != @RESULTFILES);

# load the image list file
open(FILE, "< $IMAGELISTFILE") || die "failed to open $IMAGELISTFILE\n";
my @IMAGES = <FILE>;
close(FILE);
chomp(@IMAGES); # delete newline characters

# load the image list file
open(FILE, "< $IMAGEWIDTHFILE") || die "failed to open $IMAGEWIDTHFILE\n";
my @IMAGEWIDTHS = <FILE>;
close(FILE);
chomp(@IMAGEWIDTHS); # delete newline characters

# read in the result files
my @RESULTS;
my @LINEPOSITION;
foreach $resultFile (@RESULTFILES) {
	open(FILE, "< $resultFile") || die "failed to open $resultFile\n";
	my @tmpContent = <FILE>;
	close(FILE);
	chomp(@tmpContent); # delete newline characters
	push(@RESULTS, [ @tmpContent ]);
	push(@LINEPOSITION, 1);
}

# process image by image
for (my $iImg = 0; $iImg < @IMAGES; $iImg++) {
	my $imgFile = $IMAGES[$iImg];
	print "\n### NEW IMAGE ###\nfile: $imgFile\n";

	for (my $iResult = 0; $iResult < @TYPES; $iResult++) {
		# reset some variables
#		my $counter = -1;
#		my $imgFile = "";
#		my $imgFlipped = 0;
#		my $imgResults = "";

		# get the name of the object from the pathname of the results file
#		$resultsFile =~ /(\.\/)?([^\/]+)\/.*/;
#		$dirName = $+;
#		$dirName =~ /([^_]*)_([^_]*)/;
#		$object = $1;
#		$objView = "view".ucfirst($2);
		
		my $iLine;
		for ($iLine = $LINEPOSITION[$iResult]; $iLine < @{$RESULTS[$iResult]}; $iLine++) {
			my $line = $RESULTS[$iResult][$iLine];
			$line =~ s/(^\s*|\s*$)//g; # trim the line

			# get all the different values
			my @fields = split(/\s+/, $line);

			# check wether we reached a mark indicating a new file
			if ($fields[6] == 0) {
				# break the loop
				last;
			}

			# if the image is flipped, we need the with information in order to
			# compute the positions in the 'unflipped' original image
#			if ($tmpFile) {
#				if (exists $imgWidths{$tmpFile}) {
#					$imgWidth = $imgWidths{$tmpFile};
#				}
#				else {
#					$imgWidth = `identify -format "%w" $imgFile`;
#					$imgWidth = `cat $imgFile.width`;
#					$imgWidths{$tmpFile} = $imgWidth;
#				}
#			}
			
			#
			# the object information
			#

			print "object: -1\n";
			print "type: ".$TYPES[$iResult]."\n";
			print "view: ".$VIEWS[$iResult]."\n";
			my $minX = $fields[0];
			my $minY = $fields[1];
			my $width = $fields[2];
			my $height = $fields[3];

			# see wether we gotta flip the coordinates
			if ($FLIPPED[$iResult]) {
				print "h_direction: right\n";
				$minX = $IMAGEWIDTHS[$iImg] - ($minX + $width);
			}
			else {
				print "h_direction: left\n";
			}
			
			print "bbox: $minX, $minY, $width, $height\n";
			print "score: ".$fields[5]."\n\n";
		}
		$LINEPOSITION[$iResult] = $iLine + 1;
	}
}

